---
layout: post
title: Lambda Expressions in Java
date: '2013-09-01T10:12:00.000-07:00'
author: Chandra Sekhar Nayak
tags:
- Java 8 new feature
- Java
- Functional Interfaces
- Target Types
- Lambda Expression
modified_time: '2014-08-17T02:51:28.148-07:00'
blogger_id: tag:blogger.com,1999:blog-5265809569150335007.post-3444461578430514271
blogger_orig_url: http://www.chansek.com/2013/09/lambda-expressions-in-java.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><h2 style="text-align: left;">Introduction:</h2><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Based on <a href="http://www.jcp.org/en/jsr/detail?id=335" rel="nofollow" target="_blank">JSR 335</a>, OpenJDK started&nbsp;<a href="http://openjdk.java.net/projects/lambda/" rel="nofollow" target="_blank">project lambda</a>&nbsp;to build a prototype which can make the Java language support Lambda Expressions. So in short we can say that Lambda Expression is a feature newly added in Java 8 to fulfill JSR 335. Basically it is introduced as a short form replacement of Anonymous Inner Class.</div><div style="text-align: left;"><br /></div><h2 style="text-align: left;">Why To Use It?</h2><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It has the following benefits over Anonymous Inner Classes which makes us to use this:</div><ul style="text-align: left;"><li>&nbsp; Its syntax is very neat and concise.</li><li>&nbsp; Its very easy to use and make the program more readable.</li><!-- <li>&nbsp; Its runtime overhead is very less as compare to Anonymous Inner Class.</li>--></ul><br /><h2 style="text-align: left;"></h2><h2 style="text-align: left;">Prerequisites:</h2><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; As it is a part of upcoming Java 8, you need to download the JDK 8 from&nbsp;<a href="http://jdk8.java.net/lambda/" target="_blank">this link</a>.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Before giving any examples on the usage of Lambda Expressions, we should be very clear about some of the terminologies used in this article.</div><div style="text-align: left;"><br /></div><h2 style="text-align: left;">Functional Interface:</h2><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The interfaces with one abstract method are called as Functional Interface. Lambda Expressions can only used with Functional Interfaces. The code snippet shows an example of a Functional Interface:</div><div style="text-align: left;"><br /></div><div style="text-align: left;"><br /></div></div><pre class="brush:java;"><br />public interface SayHello {<br />    String say(String message);<br />} </pre><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As interface SayHello has only one abstract method. So SayHello can be called as a Functional Interface.<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Functional Interfaces can also contain more than one methods, but the other methods should and must be the methods defined in java.lang.Object class. Here is another example of Functional Interface:<br /><br /></div><pre class="brush:java;"><br />public interface SayHello {<br />    String say(String message);<br />    String toString();<br />} </pre><br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; As the toString() method is defined in java.lang.Object class, so we can say the above interface as a Functional Interface.<br /><br /><h2 style="text-align: left;">Target Type:</h2><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The Functional Interface for which the Lambda Expression is invoked is called as the target type of the Lambda Expression.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For example: If a Lambda Expression is invoked for SayHello interface, then SayHello is the target type of that Lambda Expression.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We can say that the type of any Lambda Expression is determined by Java compiler using the Target Type of the context. So as a simple thumb rule we can conclude that Lambda Expressions can be used only in those situations where Java compiler can determine the Target Type.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Below are the areas where we can use Lambda Expressions:</div><ul style="text-align: left;"><li>&nbsp; &nbsp; Variable Declarations</li><li>&nbsp; &nbsp; Assignments</li><li>&nbsp; &nbsp; Return Statements</li><li>&nbsp;&nbsp;&nbsp; Array Initializers</li><li>&nbsp;&nbsp;&nbsp; Method or Constructer Arguments</li><li>&nbsp;&nbsp;&nbsp; Lambda Expression Bodies</li><li>&nbsp;&nbsp;&nbsp; Conditional Expressions</li><li>&nbsp;&nbsp;&nbsp; Cast Expressions</li></ul>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; As we move forward we will know how to use Lambda Expression in the given areas.<br /><br /><h2 style="text-align: left;">Syntax of Lambda Expressions:</h2><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Below is the syntax of a Lambda Expression:</div><div style="text-align: left;"></div></div><pre class="brush:java;"><br />    (formal parameter list) -> {expression or statement(s)} </pre></div><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In short we can say that it has three parts:<br /><ol style="text-align: left;"><li>&nbsp;&nbsp;&nbsp; An Arrow (-&gt;) symbol.</li><li>&nbsp;&nbsp;&nbsp; A list of formal parameters to the left side of Arrow.</li><li>&nbsp;&nbsp;&nbsp; Body part of it to the right side of the Arrow.</li></ol>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Here is the 1st example demonstrating the use of Lambda Expression:<br /><br /><pre class="brush:java;"><br />public class FirstExample {<br />    <br />    interface SayHello {<br />        String say(String message);<br />    }<br /><br />    public static void main(String[] args) {<br /><br />        //Saying hello through anonymous class<br />        SayHello helloAnonymous = new SayHello() {<br /><br />            @Override<br />            public String say(String message) {<br />                return "Hello " + message;<br />            }<br />        };<br />        System.out.println(helloAnonymous.say("Annonymous Class"));<br /><br />        //Saying hello through lambda expression<br />        SayHello helloLambdaExpr = (String message) -> "Hello " + message;<br />        System.out.println(helloLambdaExpr.say("Lambda Expression"));<br />    }<br />}<br /></pre><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; From the above example, its very clear that the syntax is very neat and concise as compare to anonymous class.<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; We need to follow some rules in order to use Lambda Expressions in our programs. Each rule will be explained with a simple example. Let's first understand the rules related to the syntax of Lambda Expression.<br /><br /><h2 style="text-align: left;">Rules for Formal Parameters of Lambda Expression: </h2><h3 style="text-align: left;">RULE 1:&nbsp;</h3><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If the abstract method of functional interface is a zero argument method, then the left hand side of the arrow(-&gt;) we must use an empty parentheses.<br /><br /><pre class="brush:java;"><br />public class SecondExample {<br /><br />    interface StaticMessage {<br />        String say();<br />    }<br /><br />    public static void main(String[] args) {<br /><br />        //Observe the empty parentheses<br />        StaticMessage msg = () -> "A Fixed Message";<br />        System.out.println(msg.say());<br />    }<br />}<br /></pre></div><div style="text-align: left;"><br /></div><h3 style="text-align: left;">RULE 2:</h3><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If the abstract method of functional interface is an one argument method, then the parentheses is not mandatory.<br /><br /><pre class="brush:java;"><br />public class ThirdExample {<br /><br />    interface SayHello {<br />        String say(String message);<br />    }<br /><br />    public static void main(String[] args) {<br />        SayHello sh = message -> "Hello " + message;<br />        System.out.println(sh.say("Lambda Expression"));<br />    }<br />}<br /></pre></div><br /><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If you closely observe the above example, you can find that the type of the formal parameter of lambda expression is not mentioned.<br /><br />NOTE: When we omit parentheses, we must omit the type of the formal parameter. Otherwise syntax error will be generated.</div><h3 style="text-align: left;">RULE 3:</h3><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If the abstract method of functional interface is an multiple argument method, then the parentheses is mandatory.</div><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Here the formal parameters should be comma separated and should be in the same order of the corresponding functional interface.</div><div style="text-align: left;"><br /><pre class="brush:java;"><br />public class FourthExample {<br /><br />    interface SayHello {<br />        String say(String message, String name, Sex sex);<br />    }<br /><br />    enum Sex {<br />        MALE, FEMALE<br />    }<br /><br />    public static void main(String[] args) {<br />        SayHello sh = (String msg, String name, Sex sex) -> {<br />                           if(sex == Sex.MALE) {<br />                               return "Hello Mr. " + name + ", " + msg;<br />                           } else {<br />                               return "Hello Ms. " + name + ", " + msg;<br />                           }<br />                      };<br />        System.out.println(sh.say("Good Morning!!!", "Ram", Sex.MALE));<br />        System.out.println(sh.say("Good Morning!!!", "Sita", Sex.FEMALE));<br />    }<br />}<br /></pre></div><h3 style="text-align: left;">RULE 4:</h3><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Mentioning type of the formal parameters are not mandatory. In case you have not mentioned the type of formal parameters, then it's type will be determined by the Java compiler from the corresponding Target Type.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Lambda expression used in the above example can be rewritten as:</div><div style="text-align: left;"><br /><pre class="brush:java;"><br />SayHello sh = (msg, name, sex) -> { <br />                                      if(sex == Sex.MALE) {<br />                                          return "Hello Mr. " + name + ", " + msg;<br />                                      } else {<br />                                          return "Hello Ms. " + name + ", " + msg;<br />                        }             };<br /></pre></div><br />CAUTION: If we want to omit the type of formal parameters, then we we have to omit it from all the parameters. Mentioning the type of some parameter and omitting from some parameter will raise compile time error.<br /><h2 style="text-align: left;">Rules for Body of Lambda Expression:</h2><h3 style="text-align: left;">RULE 1:</h3><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The body of a lambda expression can either be a single expression or one or more statements.</div><div style="text-align: left;"><br /><pre class="brush:java;"><br />public class FifthExample {<br /><br />    interface SayHello {<br />        String hello(String name);<br />    }<br /><br />    public static void main(String...args) {<br /><br />        //Saying hello through lambda expression using single expression<br />        SayHello sh1 = msg -> "Hello " + msg;<br />        System.out.println(sh1.hello("Lambda Expression With Expression"));<br /><br />        //Saying hello through lambda expression using statement<br />        SayHello sh2 = msg -> { return "Hello " + msg; };<br />        System.out.println(sh2.hello("Lambda Expression With Statement"));<br /><br />        //With multiple statements<br />        SayHello sh3 = msg -> {<br />                                String hello = "Hello " + msg;<br />                                return hello;<br />                              };<br />        System.out.println(sh3.hello("Lambda Expression With Multiple Statement"));<br />    }<br />}<br /></pre></div><h3 style="text-align: left;">RULE 2:</h3><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If we are using a single expression as body of any lambda expression, then we cannot enclose the body with curly braces({}).</div><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; In this case the evaluated value of the expression will be the return value of lambda expression. So the return statement should not be used. Because a return statement is not an expression.</div><div style="text-align: left;"><br /><pre class="brush:java;"><br />SayHello sh2 = msg -> {"Hello " + msg }; // Compile time error.<br />SayHello sh = msg -> "Hello " + msg; // Runs fine<br /></pre></div><h3 style="text-align: left;">RULE 3:</h3><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If we are using one or more statements as body of any lambda expression, then enclosing them within curly braces({}) is mandatory.</div><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Here return statement is mandatory, if the method of the functional interface has nay return type.</div><div style="text-align: left;"><br /><pre class="brush:java;"><br />SayHello sh = msg -> {String hello = "Hello " + msg; }; // Compile time error, No return statement<br />SayHello sh = msg -> {String hello = "Hello " + msg; return hello; }; // Runs fine<br /></pre></div><h2 style="text-align: left;">Local variables in Lambda Expressions:</h2><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; These are the following rules we need to follow in case of local variables in lambda expressions.</div><div style="text-align: left;"><br /></div><h3 style="text-align: left;">RULE 1:</h3><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Lambda Expressions doesn't define any new scope like what anonymous inner class does, so we can not declare a local variable with same which is already declared in the enclosing scope of the lambda expression.</div><div style="text-align: left;"><br /><pre class="brush:java;"><br />public class SixthExample {<br /><br />    interface Algebra {<br />        int add(int a);<br />    }<br /><br />    public static void main(String[] args) {<br /><br />        // Declaring a variable<br />        int x = 10;<br />        Algebra alg = a -> {<br />                            int x = 20;<br />                            return a + x;<br />                           };<br />        System.out.println("10 + 20 = " + alg.add(10));<br /><br />        // Above will generate error saying variable x is already defined in main(String[])<br />        // Because lambda expression doesn't define a new scope.<br />        // But anonymous class does, so comment the above one and<br />        // try the below one, it will work fine<br /><br />        // Using Anonymous class<br />        Algebra alg1 = new Algebra() {<br /><br />                @Override<br />                public int add(int a) {<br />                    int x = 20;<br />                    return a + x;<br />                }<br />        };<br />        System.out.println("10 + 20 = " + alg1.add(10));<br />    }<br />}<br /></pre></div><h3 style="text-align: left;">RULE 2:</h3><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Inside Lambda Expression, we cannot assign any value to some local variable declared outside the lambda expression. Because the local variables declared outside the lambda expression (inside the enclosing scope of the lambda expression) should be final or effectively final.</div><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Here effectively final means we can only use those variables but we cannot modify those inside lambda expression.</div><div style="text-align: left;"><br /><pre class="brush:java;"><br />public static void main(String[] args) {<br /><br />    // Declaring a variable<br />    int x = 10;<br />    Algebra alg = a -> {<br />                         x = 20;<br />                         return a + x;<br />                       };<br />    System.out.println("10 + 20 = " + alg.add(10));<br /><br />    // Above will generate error saying local variable referenced from<br />    // lambda expression must be final or effectively final<br />}<br /></pre></div><h3 style="text-align: left;">RULE 3:</h3><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The rule of final or effectively final is also applicable for method parameters and exception parameters.</div><div style="text-align: left;"><br /><pre class="brush:java;"><br />public class SeventhExample {<br /><br />    interface Algebra {<br />        int add(int a);<br />    }<br /><br />    public static void main(String[] args) {<br />        System.out.println("10 + 10 = " + getResult(20));<br />    }<br /><br />    static int getResult(int x) {<br />        Algebra alg = a -> {<br />                             x = 10; //This will generate the same error as above case<br />                             return a + x;<br />                           };<br />        return alg.add(10);<br />    }<br />}<br /></pre></div><h3 style="text-align: left;">RULE 4:</h3><div style="text-align: left;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>this</i> and <i>super</i> references inside the lambda body are same as their enclosing scope. Because we know lambda expressions doesn't define any new scope.</div><div style="text-align: left;"><br /><pre class="brush:java;"><br />public class EighthExample {<br /><br />    int x = 10;<br /><br />    interface SayHello {<br />        String say(String message);<br />    }<br /><br />    public static void main(String[] args) {<br />        EighthExample obj = new EighthExample();<br />        obj.show();<br />    }<br /><br />    public void show() {<br />        SayHello sh = new SayHello() {<br />                @Override<br />                public String say(String message) {<br />                    System.out.println(this.x); //Compile time error, x cannot be resolved<br />                    return "Hello " + message;<br />                }<br />        };<br />        System.out.println(sh.say("Anonymous"));<br /><br />        SayHello sh1 = msg -> {<br />                                System.out.println(this.x); //Prints 10<br />                                return "Hello " + msg;<br />                              };<br />        System.out.println(sh1.say("Lambda"));<br />    }<br />}<br /></pre></div><h2 style="text-align: left;">Exception Handling in Lambda Expression:</h2><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Following are the rules we need to follow in order to use exception handling mechanism of Java.</div><div><br /></div><h3>RULE 1:</h3><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Lambda expression cannot throw any checked exception until its corresponding functional interface declares a throws clause.</div><div><br /><pre class="brush:java;"><br />public class NinthExample {<br /><br />    interface ThrowException {<br />        void throwing(String message);<br />    }<br /><br />    public static void main(String[] args) {<br />        ThrowException te = msg -> {<br />                                     throw new Exception(msg);<br />                                     //Cannot be thrown as throwing(String)<br />                                     //doesn't define any throws clause<br />                                     //Now comment the above one and rerun,<br />                                     //it will work fine as RuntimeException<br />                                     //is not checked exception<br />                                     throw new RuntimeException(msg);<br />                                   };<br />        te.throwing("Lambda");<br />    }<br />}<br /></pre></div><br /><h3>RULE 2:</h3><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The exception thrown by any lambda expression should be of same type or sub-type of the exception type declared in the throws clause of its functional interface.</div><div><br /><pre class="brush:java;"><br />public class TenthExample {<br /><br />    interface ThrowException {<br />        void throwing(String message) throws IOException;<br />    }<br /><br />    public static void main(String[] args) throws Exception {<br /><br />        ThrowException te = msg -> {<br />                                     //Runs fine<br />                                     throw new IOException(msg);<br />                                     //Compile time error. As Exception is not the sub-type of IOException<br />                                     throw new Exception(msg);<br />                                     //Runs fine as FileNotFoundException is a sub-type of IOException<br />                                     throw new FileNotFoundException(msg);<br />                                   };<br />        te.throwing("Lambda");<br />    }<br />}<br /></pre></div><br /><h2>Lambda Expression in return Statement:</h2><div><pre class="brush:java;"><br />public class ReturnExample {<br /><br />    interface Algebra {<br />        int add(int a, int b);<br />    }<br /><br />    public static Algebra getAlgebra() {<br />        return (a, b) -> a + b;<br />    }<br /><br />    public static void main(String...args) {<br />        System.out.println("10 + 20 = " + getAlgebra().add(10, 20));<br />    }<br />}<br /></pre></div><br /><h2 style="text-align: left;">Lambda Expression in Array Initializers:</h2><div><pre class="brush:java;"><br />public class ArrayInitExample {<br /><br />    interface Algebra {<br />        int operate(int a, int b);<br />    }<br /><br />    public static void main(String[] args) {<br />        Algebra al[] = new Algebra[] {<br />                                       (a, b) -> a+b,<br />                                       (a, b) -> a-b,<br />                                       (a, b) -> a*b,<br />                                       (a, b) -> a/b<br />                                     };<br />        System.out.println("10 + 20 = " + al[0].operate(10, 20));<br />        System.out.println("10 - 20 = " + al[1].operate(10, 20));<br />        System.out.println("10 * 20 = " + al[2].operate(10, 20));<br />        System.out.println("10 / 20 = " + al[3].operate(10, 20));<br />    }<br />}<br /></pre></div><h2 style="text-align: left;">Lambda Expression as Method or Constructor Arguments:</h2><div><pre class="brush:java;"><br />public class MethodArgExample {<br /><br />    interface Algebra {<br />        int operate(int a, int b);<br />    }<br /><br />    enum Operation {<br />        ADD, SUB, MUL, DIV<br />    }<br /><br />    public static void main(String[] args) {<br />        printValue((a, b) -> a + b, Operation.ADD);<br />        printValue((a, b) -> a - b, Operation.SUB);<br />        printValue((a, b) -> a * b, Operation.MUL);<br />        printValue((a, b) -> a / b, Operation.DIV);<br />    }<br /><br />    static void printValue(Algebra a, Operation op) {<br />        switch (op) {<br />        case ADD:<br />            System.out.println("10 + 20 = " + a.operate(10, 20));<br />            break;<br />        case SUB:<br />            System.out.println("10 - 20 = " + a.operate(10, 20));<br />            break;<br />        case MUL:<br />            System.out.println("10 * 20 = " + a.operate(10, 20));<br />            break;<br />        case DIV:<br />            System.out.println("10 / 20 = " + a.operate(10, 20));<br />            break;<br />        default:<br />            throw new AssertionError();<br />        }<br />    }<br />}<br /></pre></div><br /><h2 style="text-align: left;">Lambda Expression in Conditional Expression:</h2><div><br /><pre class="brush:java;"><br />public class ConditionalExprExample {<br /><br />    interface Algebra {<br />        int substract(int a, int b);<br />    }<br /><br />    public static void main(String...args) {<br />        System.out.println(getAlgebra(false).substract(10, 20));<br />        System.out.println(getAlgebra(true).substract(20, 10));<br />    }<br /><br />    static Algebra getAlgebra(boolean reverse) {<br />        Algebra al = reverse ? (a, b) -> a - b : (a, b) -> b - a;<br />        return al;<br />    }<br />}<br /></pre></div><h2 style="text-align: left;">Lambda Expression in Casting Expression:</h2><div><pre class="brush:java;"><br />public class CastingExample {<br /><br />    interface Algebra {<br />        int operate(int a, int b);<br />    }<br /><br />    interface Algebra1 {<br />        int operate(int a, int b);<br />    }<br /><br />    public static void main(String[] args) {<br />        printResult((a, b) -> a + b);<br />    }<br /><br />    static void printResult(Algebra a) {<br />        System.out.println("From Algebra Interface");<br />        System.out.println(a.operate(10, 20));<br />    }<br /><br />    static void printResult(Algebra1 a) {<br />        System.out.println("From Algebra1 Interface");<br />        System.out.println(a.operate(10, 20));<br />    }<br />}<br /></pre></div><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The above example will generate an ambiguous error, because both the printResult() methods are valid. So to avoid this type of situations you need to type cast the lambda expression as follows:<br /><br /><pre class="brush:java;"><br />public static void main(String...args) {<br />    printResult((Algebra)(a, b) -> a + b); //Calls printResult(Algebra)<br />    printResult((Algebra1)(a, b) -> a + b); //Calls printResult(Algebra1)<br />}<br /></pre><br /><h2 style="text-align: left;">Conclusion:</h2><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; As the examples above shown tells that it is a short form replacement of anonymous inner class, we should not assume that it will replace the anonymous class. Because you should remember very carefully that lambda expression will only work with respect to functional interfaces whereas anonymous class can work with any type of interfaces.</div><div><br /></div><h2 style="text-align: left;">References:</h2><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="nofollow" target="_blank">Oracle documentation for Lambda Expression</a></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<a href="http://www.oracle.com/technetwork/articles/java/lambda-1984522.html" rel="nofollow" target="_blank">Lambda Expressions by Deepak Vohra</a><br /><br /><h2 style="text-align: left;">Feedback:</h2></div><div style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anybody who finds any kind of mistakes in this article, please let me know either through comment or mail.</div><ol style="text-align: left;"></ol></div>